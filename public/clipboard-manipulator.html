<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Clipboard Tool</title>

  
  <link rel="stylesheet" href="style.css" />
  <script defer src="theme-selector.js"></script>
</head>

<body class="theme-root page-body">
  <main class="page-main">
<div class="wrap">
    <header>
      <div class="titleRow">
        <h1>Clipboard Tool</h1>
        <span class="small">Mobile-friendly</span>
      </div>
      <p class="hint">
        Clipboard read/write usually requires HTTPS and a user gesture (a tap).
        Some browsers limit HTML clipboard access.
      </p>
    </header>

    <section class="card">
      <textarea id="clipText" placeholder="Paste or type here…"></textarea>
      <div class="meta">
        <div id="charCount">0 characters</div>
        <div id="supportInfo"></div>
      </div>
    </section>

    <section class="card">
      <div class="grid two">
        <button id="btnReadText">Read Text</button>
        <button id="btnWriteText">Write Text</button>

        <button id="btnReadHtml">Read HTML</button>
        <button id="btnWriteHtml">Write HTML</button>

        <button id="btnSelectAll">Select All</button>
        <button id="btnClear">Clear</button>
      </div>
      <p class="small" style="margin-top:10px;">
        Tip: If <code class="kbd">Read HTML</code> is not supported, use <code class="kbd">Read Text</code>.
      </p>
    </section>

    <section class="card">
      <div class="field">
        <label for="fontSize">Font size</label>
        <input id="fontSize" type="range" min="8" max="72" step="1" value="16" />
        <input id="fontSizeNum" type="number" min="8" max="72" step="1" value="16" />
      </div>
      <div class="grid two" style="margin-top:10px;">
        <button id="btnWrapFont">Wrap as HTML with Font Size</button>
        <button id="btnPreviewFont">Preview Font Size (local)</button>
      </div>
      <p class="small" style="margin-top:10px;">
        “Wrap as HTML” writes <code class="kbd">text/html</code> and <code class="kbd">text/plain</code> to the clipboard.
      </p>
    </section>

    <section class="card">
      <div id="status" class="status">Ready.</div>
    </section>
  </div>

  <script>
    (function () {
      const textarea = document.getElementById("clipText");
      const statusEl = document.getElementById("status");
      const charCountEl = document.getElementById("charCount");
      const supportInfoEl = document.getElementById("supportInfo");

      const btnReadText = document.getElementById("btnReadText");
      const btnWriteText = document.getElementById("btnWriteText");
      const btnReadHtml = document.getElementById("btnReadHtml");
      const btnWriteHtml = document.getElementById("btnWriteHtml");
      const btnSelectAll = document.getElementById("btnSelectAll");
      const btnClear = document.getElementById("btnClear");

      const fontSize = document.getElementById("fontSize");
      const fontSizeNum = document.getElementById("fontSizeNum");
      const btnWrapFont = document.getElementById("btnWrapFont");
      const btnPreviewFont = document.getElementById("btnPreviewFont");

      // --- helpers ---
      function setStatus(message, type = "info") {
        statusEl.classList.remove("ok", "err");
        if (type === "ok") statusEl.classList.add("ok");
        if (type === "err") statusEl.classList.add("err");
        statusEl.textContent = message;
      }

      function updateMeta() {
        const len = textarea.value.length;
        charCountEl.textContent = `${len.toLocaleString()} characters`;
      }

      function autoResize() {
        // Keep it simple and compatible
        textarea.style.height = "auto";
        textarea.style.height = textarea.scrollHeight + "px";
      }

      function escapeHtml(s) {
        const span = document.createElement("span");
        span.textContent = s;
        return span.innerHTML;
      }

      function isSecureContextInfo() {
        return window.isSecureContext ? "Secure context: yes" : "Secure context: no";
      }

      function supportInfo() {
        const hasClipboard = !!navigator.clipboard;
        const canReadText = hasClipboard && typeof navigator.clipboard.readText === "function";
        const canWriteText = hasClipboard && typeof navigator.clipboard.writeText === "function";
        const canRead = hasClipboard && typeof navigator.clipboard.read === "function";   // for HTML
        const canWrite = hasClipboard && typeof navigator.clipboard.write === "function"; // for HTML
        return { hasClipboard, canReadText, canWriteText, canRead, canWrite };
      }

      async function guardClipboardPermissions(operationName) {
        // Permissions API varies; do best-effort without hard failing.
        try {
          if (!navigator.permissions || !navigator.permissions.query) return;
          // Common names: "clipboard-read", "clipboard-write"
          // Some browsers throw if unknown; catch and continue.
          const permName = operationName === "read" ? "clipboard-read" : "clipboard-write";
          await navigator.permissions.query({ name: permName });
        } catch (_) {
          // ignore
        }
      }

      // --- init ---
      textarea.addEventListener("input", () => {
        autoResize();
        updateMeta();
      });

      // Make sure initial sizing is ok on mobile
      autoResize();
      updateMeta();

      // Support display + disable unsupported actions
      const sup = supportInfo();
      supportInfoEl.textContent = `${isSecureContextInfo()}`;

      btnReadText.disabled = !sup.canReadText;
      btnWriteText.disabled = !sup.canWriteText;

      // HTML access is often unsupported on iOS Safari / restricted environments
      btnReadHtml.disabled = !sup.canRead;
      btnWriteHtml.disabled = !sup.canWrite;

      if (!sup.hasClipboard) {
        setStatus("Clipboard API not available in this browser.", "err");
      } else if (!window.isSecureContext) {
        setStatus("This page is not in a secure context (HTTPS). Clipboard operations may fail.", "err");
      }

      // --- actions ---
      btnReadText.addEventListener("click", async () => {
        try {
          await guardClipboardPermissions("read");
          const plain = await navigator.clipboard.readText();
          textarea.value = plain;
          autoResize();
          updateMeta();
          setStatus("Read text from clipboard.", "ok");
        } catch (e) {
          setStatus(`Failed to read text: ${e && e.message ? e.message : String(e)}`, "err");
        }
      });

      btnWriteText.addEventListener("click", async () => {
        try {
          await guardClipboardPermissions("write");
          await navigator.clipboard.writeText(textarea.value);
          setStatus("Wrote text to clipboard.", "ok");
        } catch (e) {
          setStatus(`Failed to write text: ${e && e.message ? e.message : String(e)}`, "err");
        }
      });

      btnReadHtml.addEventListener("click", async () => {
        try {
          await guardClipboardPermissions("read");
          const items = await navigator.clipboard.read();
          let html = null;

          for (const item of items) {
            if (item.types && item.types.includes("text/html")) {
              const blob = await item.getType("text/html");
              html = await blob.text();
              break;
            }
          }

          if (html == null) {
            throw new Error("No text/html found in clipboard.");
          }

          textarea.value = html;
          autoResize();
          updateMeta();
          setStatus("Read HTML from clipboard.", "ok");
        } catch (e) {
          setStatus(`Failed to read HTML: ${e && e.message ? e.message : String(e)}`, "err");
        }
      });

      btnWriteHtml.addEventListener("click", async () => {
        try {
          await guardClipboardPermissions("write");

          const htmlText = textarea.value;
          const htmlDoc = new DOMParser().parseFromString(htmlText, "text/html");
          const plainText = htmlDoc.body ? htmlDoc.body.innerText : "";
          const blobHtml = new Blob([htmlText], { type: "text/html" });
          const blobPlain = new Blob([plainText], { type: "text/plain" });
          const data = [new ClipboardItem({ "text/html": blobHtml, "text/plain": blobPlain })];

          await navigator.clipboard.write(data);
          setStatus("Wrote HTML to clipboard.", "ok");
        } catch (e) {
          setStatus(`Failed to write HTML: ${e && e.message ? e.message : String(e)}`, "err");
        }
      });

      btnSelectAll.addEventListener("click", () => {
        textarea.focus();
        textarea.select();
        setStatus("Selected all text.", "ok");
      });

      btnClear.addEventListener("click", () => {
        textarea.value = "";
        autoResize();
        updateMeta();
        setStatus("Cleared.", "ok");
      });

      // --- font size controls ---
      function syncFontControls(from) {
        const v = Math.max(8, Math.min(72, Number(from.value || 16)));
        fontSize.value = String(v);
        fontSizeNum.value = String(v);
      }

      fontSize.addEventListener("input", () => syncFontControls(fontSize));
      fontSizeNum.addEventListener("input", () => syncFontControls(fontSizeNum));

      btnPreviewFont.addEventListener("click", () => {
        const v = Number(fontSize.value || 16);
        textarea.style.fontSize = v + "px";
        autoResize();
        setStatus(`Previewed font size: ${v}px (local only).`, "ok");
      });

      btnWrapFont.addEventListener("click", async () => {
        try {
          await guardClipboardPermissions("write");

          const v = Number(fontSize.value || 16);
          const plainText = textarea.value;

          // Wrap as HTML safely
          const htmlText = `<span style="font-size:${v}px;">${escapeHtml(plainText)}</span>`;

          const blobHtml = new Blob([htmlText], { type: "text/html" });
          const blobPlain = new Blob([plainText], { type: "text/plain" });
          const data = [new ClipboardItem({ "text/html": blobHtml, "text/plain": blobPlain })];

          await navigator.clipboard.write(data);
          setStatus(`Wrote wrapped HTML with font size ${v}px to clipboard.`, "ok");
        } catch (e) {
          setStatus(`Failed to wrap/write HTML: ${e && e.message ? e.message : String(e)}`, "err");
        }
      });

      // initial sync
      syncFontControls(fontSize);
    })();
  </script>
  </main>
</body>
</html>
